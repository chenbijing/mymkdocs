{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"FAQ/","title":"Frequently Asked Questions","text":""},{"location":"FAQ/#how-can-i-donate-to-the-project","title":"How can I donate to the project?","text":"<p>Thank you for your support. See the Sponsors page for information.</p>"},{"location":"FAQ/#how-do-i-calculate-the-rotation_distance-config-parameter","title":"How do I calculate the rotation_distance config parameter?","text":"<p>See the rotation distance document.</p>"},{"location":"FAQ/#wheres-my-serial-port","title":"Where's my serial port?","text":"<p>The general way to find a USB serial port is to run <code>ls /dev/serial/by-id/*</code> from an ssh terminal on the host machine. It will likely produce output similar to the following:</p> <pre><code>/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0\n</code></pre> <p>The name found in the above command is stable and it is possible to use it in the config file and while flashing the micro-controller code. For example, a flash command might look similar to:</p> <pre><code>sudo service klipper stop\nmake flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0\nsudo service klipper start\n</code></pre> <p>and the updated config might look like:</p> <pre><code>[mcu]\nserial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0\n</code></pre> <p>Be sure to copy-and-paste the name from the \"ls\" command that you ran above as the name will be different for each printer.</p> <p>If you are using multiple micro-controllers and they do not have unique ids (common on boards with a CH340 USB chip) then follow the directions above using the command <code>ls /dev/serial/by-path/*</code> instead.</p>"},{"location":"FAQ/#when-the-micro-controller-restarts-the-device-changes-to-devttyusb1","title":"When the micro-controller restarts the device changes to /dev/ttyUSB1","text":"<p>Follow the directions in the \"Where's my serial port?\" section to prevent this from occurring.</p>"},{"location":"FAQ/#the-make-flash-command-doesnt-work","title":"The \"make flash\" command doesn't work","text":"<p>The code attempts to flash the device using the most common method for each platform. Unfortunately, there is a lot of variance in flashing methods, so the \"make flash\" command may not work on all boards.</p> <p>If you're having an intermittent failure or you do have a standard setup, then double check that Klipper isn't running when flashing (sudo service klipper stop), make sure OctoPrint isn't trying to connect directly to the device (open the Connection tab in the web page and click Disconnect if the Serial Port is set to the device), and make sure FLASH_DEVICE is set correctly for your board (see the question above).</p> <p>However, if \"make flash\" just doesn't work for your board, then you will need to manually flash. See if there is a config file in the config directory with specific instructions for flashing the device. Also, check the board manufacturer's documentation to see if it describes how to flash the device. Finally, it may be possible to manually flash the device using tools such as \"avrdude\" or \"bossac\" - see the bootloader document for additional information.</p>"},{"location":"FAQ/#how-do-i-change-the-serial-baud-rate","title":"How do I change the serial baud rate?","text":"<p>The recommended baud rate for Klipper is 250000. This baud rate works well on all micro-controller boards that Klipper supports. If you've found an online guide recommending a different baud rate, then ignore that part of the guide and continue with the default value of 250000.</p> <p>If you want to change the baud rate anyway, then the new rate will need to be configured in the micro-controller (during make menuconfig) and that updated code will need to be compiled and flashed to the micro-controller. The Klipper printer.cfg file will also need to be updated to match that baud rate (see the config reference for details).  For example:</p> <pre><code>[mcu]\nbaud: 250000\n</code></pre> <p>The baud rate shown on the OctoPrint web page has no impact on the internal Klipper micro-controller baud rate. Always set the OctoPrint baud rate to 250000 when using Klipper.</p> <p>The Klipper micro-controller baud rate is not related to the baud rate of the micro-controller's bootloader. See the bootloader document for additional information on bootloaders.</p>"},{"location":"FAQ/#can-i-run-klipper-on-something-other-than-a-raspberry-pi-3","title":"Can I run Klipper on something other than a Raspberry Pi 3?","text":"<p>The recommended hardware is a Raspberry Pi 2, Raspberry Pi 3, or Raspberry Pi 4.</p> <p>Klipper will run on a Raspberry Pi 1 and on the Raspberry Pi Zero, but these boards don't have enough processing power to run OctoPrint well. It is common for print stalls to occur on these slower machines when printing directly from OctoPrint. (The printer may move faster than OctoPrint can send movement commands.) If you wish to run on one one of these slower boards anyway, consider using the \"virtual_sdcard\" feature when printing (see config reference for details).</p> <p>For running on the Beaglebone, see the Beaglebone specific installation instructions.</p> <p>Klipper has been run on other machines. The Klipper host software only requires Python running on a Linux (or similar) computer. However, if you wish to run it on a different machine you will need Linux admin knowledge to install the system prerequisites for that particular machine. See the install-octopi.sh script for further information on the necessary Linux admin steps.</p> <p>If you are looking to run the Klipper host software on a low-end chip, then be aware that, at a minimum, a machine with \"double precision floating point\" hardware is required.</p> <p>If you are looking to run the Klipper host software on a shared general-purpose desktop or server class machine, then note that Klipper has some real-time scheduling requirements. If, during a print, the host computer also performs an intensive general-purpose computing task (such as defragmenting a hard drive, 3d rendering, heavy swapping, etc.), then it may cause Klipper to report print errors.</p> <p>Note: If you are not using an OctoPi image, be aware that several Linux distributions enable a \"ModemManager\" (or similar) package that can disrupt serial communication. (Which can cause Klipper to report seemingly random \"Lost communication with MCU\" errors.) If you install Klipper on one of these distributions you may need to disable that package.</p>"},{"location":"FAQ/#can-i-run-multiple-instances-of-klipper-on-the-same-host-machine","title":"Can I run multiple instances of Klipper on the same host machine?","text":"<p>It is possible to run multiple instances of the Klipper host software, but doing so requires Linux admin knowledge. The Klipper installation scripts ultimately cause the following Unix command to be run:</p> <pre><code>~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l /tmp/klippy.log\n</code></pre> <p>One can run multiple instances of the above command as long as each instance has its own printer config file, its own log file, and its own pseudo-tty. For example:</p> <pre><code>~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l /tmp/klippy2.log -I /tmp/printer2\n</code></pre> <p>If you choose to do this, you will need to implement the necessary start, stop, and installation scripts (if any). The install-octopi.sh script and the klipper-start.sh script may be useful as examples.</p>"},{"location":"FAQ/#do-i-have-to-use-octoprint","title":"Do I have to use OctoPrint?","text":"<p>The Klipper software is not dependent on OctoPrint. It is possible to use alternative software to send commands to Klipper, but doing so requires Linux admin knowledge.</p> <p>Klipper creates a \"virtual serial port\" via the \"/tmp/printer\" file, and it emulates a classic 3d-printer serial interface via that file. In general, alternative software may work with Klipper as long as it can be configured to use \"/tmp/printer\" for the printer serial port.</p>"},{"location":"FAQ/#why-cant-i-move-the-stepper-before-homing-the-printer","title":"Why can't I move the stepper before homing the printer?","text":"<p>The code does this to reduce the chance of accidentally commanding the head into the bed or a wall. Once the printer is homed the software attempts to verify each move is within the position_min/max defined in the config file. If the motors are disabled (via an M84 or M18 command) then the motors will need to be homed again prior to movement.</p> <p>If you want to move the head after canceling a print via OctoPrint, consider changing the OctoPrint cancel sequence to do that for you. It's configured in OctoPrint via a web browser under: Settings-&gt;GCODE Scripts</p> <p>If you want to move the head after a print finishes, consider adding the desired movement to the \"custom g-code\" section of your slicer.</p> <p>If the printer requires some additional movement as part of the homing process itself (or fundamentally does not have a homing process) then consider using a safe_z_home or homing_override section in the config file. If you need to move a stepper for diagnostic or debugging purposes then consider adding a force_move section to the config file. See config reference for further details on these options.</p>"},{"location":"FAQ/#why-is-the-z-position_endstop-set-to-05-in-the-default-configs","title":"Why is the Z position_endstop set to 0.5 in the default configs?","text":"<p>For cartesian style printers the Z position_endstop specifies how far the nozzle is from the bed when the endstop triggers. If possible, it is recommended to use a Z-max endstop and home away from the bed (as this reduces the potential for bed collisions). However, if one must home towards the bed then it is recommended to position the endstop so it triggers when the nozzle is still a small distance away from the bed. This way, when homing the axis, it will stop before the nozzle touches the bed. See the bed level document for more information.</p>"},{"location":"FAQ/#i-converted-my-config-from-marlin-and-the-xy-axes-work-fine-but-i-just-get-a-screeching-noise-when-homing-the-z-axis","title":"I converted my config from Marlin and the X/Y axes work fine, but I just get a screeching noise when homing the Z axis","text":"<p>Short answer: First, make sure you have verified the stepper configuration as described in the config check document. If the problem persists, try reducing the max_z_velocity setting in the printer config.</p> <p>Long answer: In practice Marlin can typically only step at a rate of around 10000 steps per second. If it is requested to move at a speed that would require a higher step rate then Marlin will generally just step as fast as it can. Klipper is able to achieve much higher step rates, but the stepper motor may not have sufficient torque to move at a higher speed. So, for a Z axis with a high gearing ratio or high microsteps setting the actual obtainable max_z_velocity may be smaller than what is configured in Marlin.</p>"},{"location":"FAQ/#my-tmc-motor-driver-turns-off-in-the-middle-of-a-print","title":"My TMC motor driver turns off in the middle of a print","text":"<p>If using the TMC2208 (or TMC2224) driver in \"standalone mode\" then make sure to use the latest version of Klipper. A workaround for a TMC2208 \"stealthchop\" driver problem was added to Klipper in mid-March of 2020.</p>"},{"location":"FAQ/#i-keep-getting-random-lost-communication-with-mcu-errors","title":"I keep getting random \"Lost communication with MCU\" errors","text":"<p>This is commonly caused by hardware errors on the USB connection between the host machine and the micro-controller. Things to look for: - Use a good quality USB cable between the host machine and   micro-controller. Make sure the plugs are secure. - If using a Raspberry Pi, use a   good quality power supply   for the Raspberry Pi and use a   good quality USB cable   to connect that power supply to the Pi. If you get \"under voltage\"   warnings from OctoPrint, this is related to the power supply and it   must be fixed. - Make sure the printer's power supply is not being overloaded. (Power   fluctuations to the micro-controller's USB chip may result in resets   of that chip.) - Verify stepper, heater, and other printer wires are not crimped or   frayed. (Printer movement may place stress on a faulty wire causing   it to lose contact, briefly short, or generate excessive noise.) - There have been reports of high USB noise when both the printer's   power supply and the host's 5V power supply are mixed. (If you find   that the micro-controller powers on when either the printer's power   supply is on or the USB cable is plugged in, then it indicates the   5V power supplies are being mixed.) It may help to configure the   micro-controller to use power from only one source. (Alternatively,   if the micro-controller board can not configure its power source,   one may modify a USB cable so that it does not carry 5V power   between the host and micro-controller.)</p>"},{"location":"FAQ/#my-raspberry-pi-keeps-rebooting-during-prints","title":"My Raspberry Pi keeps rebooting during prints","text":"<p>This is most likely do to voltage fluctuations. Follow the same troubleshooting steps for a \"Lost communication with MCU\" error.</p>"},{"location":"FAQ/#when-i-set-restart_methodcommand-my-avr-device-just-hangs-on-a-restart","title":"When I set <code>restart_method=command</code> my AVR device just hangs on a restart","text":"<p>Some old versions of the AVR bootloader have a known bug in watchdog event handling. This typically manifests when the printer.cfg file has restart_method set to \"command\". When the bug occurs, the AVR device will be unresponsive until power is removed and reapplied to the device (the power or status LEDs may also blink repeatedly until the power is removed).</p> <p>The workaround is to use a restart_method other than \"command\" or to flash an updated bootloader to the AVR device. Flashing a new bootloader is a one time step that typically requires an external programmer - see Bootloaders for further details.</p>"},{"location":"FAQ/#will-the-heaters-be-left-on-if-the-raspberry-pi-crashes","title":"Will the heaters be left on if the Raspberry Pi crashes?","text":"<p>The software has been designed to prevent that. Once the host enables a heater, the host software needs to confirm that enablement every 5 seconds. If the micro-controller does not receive a confirmation every 5 seconds it goes into a \"shutdown\" state which is designed to turn off all heaters and stepper motors.</p> <p>See the \"config_digital_out\" command in the MCU commands document for further details.</p> <p>In addition, the micro-controller software is configured with a minimum and maximum temperature range for each heater at startup (see the min_temp and max_temp parameters in the config reference for details). If the micro-controller detects that the temperature is outside of that range then it will also enter a \"shutdown\" state.</p> <p>Separately, the host software also implements code to check that heaters and temperature sensors are functioning correctly. See the config reference for further details.</p>"},{"location":"FAQ/#how-do-i-convert-a-marlin-pin-number-to-a-klipper-pin-name","title":"How do I convert a Marlin pin number to a Klipper pin name?","text":"<p>Short answer: A mapping is available in the sample-aliases.cfg file. Use that file as a guide to finding the actual micro-controller pin names. (It is also possible to copy the relevant board_pins config section into your config file and use the aliases in your config, but it is preferable to translate and use the actual micro-controller pin names.) Note that the sample-aliases.cfg file uses pin names that start with the prefix \"ar\" instead of \"D\" (eg, Arduino pin <code>D23</code> is Klipper alias <code>ar23</code>) and the prefix \"analog\" instead of \"A\" (eg, Arduino pin <code>A14</code> is Klipper alias <code>analog14</code>).</p> <p>Long answer: Klipper uses the standard pin names defined by the micro-controller. On the Atmega chips these hardware pins have names like <code>PA4</code>, <code>PC7</code>, or <code>PD2</code>.</p> <p>Long ago, the Arduino project decided to avoid using the standard hardware names in favor of their own pin names based on incrementing numbers - these Arduino names generally look like <code>D23</code> or <code>A14</code>. This was an unfortunate choice that has lead to a great deal of confusion. In particular the Arduino pin numbers frequently don't translate to the same hardware names. For example, <code>D21</code> is <code>PD0</code> on one common Arduino board, but is <code>PC7</code> on another common Arduino board.</p> <p>To avoid this confusion, the core Klipper code uses the standard pin names defined by the micro-controller.</p>"},{"location":"FAQ/#do-i-have-to-wire-my-device-to-a-specific-type-of-micro-controller-pin","title":"Do I have to wire my device to a specific type of micro-controller pin?","text":"<p>It depends on the type of device and type of pin:</p> <p>ADC pins (or Analog pins): For thermistors and similar \"analog\" sensors, the device must be wired to an \"analog\" or \"ADC\" capable pin on the micro-controller. If you configure Klipper to use a pin that is not analog capable, Klipper will report a \"Not a valid ADC pin\" error.</p> <p>PWM pins (or Timer pins): Klipper does not use hardware PWM by default for any device. So, in general, one may wire heaters, fans, and similar devices to any general purpose IO pin. However, fans and output_pin devices may be optionally configured to use <code>hardware_pwm: True</code>, in which case the micro-controller must support hardware PWM on the pin (otherwise, Klipper will report a \"Not a valid PWM pin\" error).</p> <p>IRQ pins (or Interrupt pins): Klipper does not use hardware interrupts on IO pins, so it is never necessary to wire a device to one of these micro-controller pins.</p> <p>SPI pins: When using hardware SPI it is necessary to wire the pins to the micro-controller's SPI capable pins. However, most devices can be configured to use \"software SPI\", in which case any general purpose IO pins may be used.</p> <p>I2C pins: When using I2C it is necessary to wire the pins to the micro-controller's I2C capable pins.</p> <p>Other devices may be wired to any general purpose IO pin. For example, steppers, heaters, fans, Z probes, servos, LEDs, common hd44780/st7920 LCD displays, the Trinamic UART control line may be wired to any general purpose IO pin.</p>"},{"location":"FAQ/#how-do-i-cancel-an-m109m190-wait-for-temperature-request","title":"How do I cancel an M109/M190 \"wait for temperature\" request?","text":"<p>Navigate to the OctoPrint terminal tab and issue an M112 command in the terminal box. The M112 command will cause Klipper to enter into a \"shutdown\" state, and it will cause OctoPrint to disconnect from Klipper. Navigate to the OctoPrint connection area and click on \"Connect\" to cause OctoPrint to reconnect. Navigate back to the terminal tab and issue a FIRMWARE_RESTART command to clear the Klipper error state.  After completing this sequence, the previous heating request will be canceled and a new print may be started.</p>"},{"location":"FAQ/#can-i-find-out-whether-the-printer-has-lost-steps","title":"Can I find out whether the printer has lost steps?","text":"<p>In a way, yes. Home the printer, issue a <code>GET_POSITION</code> command, run your print, home again and issue another <code>GET_POSITION</code>. Then compare the values in the <code>mcu:</code> line.</p> <p>This might be helpful to tune settings like stepper motor currents, accelerations and speeds without needing to actually print something and waste filament: just run some high-speed moves in between the <code>GET_POSITION</code> commands.</p> <p>Note that endstop switches themselves tend to trigger at slightly different positions, so a difference of a couple of microsteps is likely the result of endstop inaccuracies. A stepper motor itself can only lose steps in increments of 4 full steps. (So, if one is using 16 microsteps, then a lost step on the stepper would result in the \"mcu:\" step counter being off by a multiple of 64 microsteps.)</p>"},{"location":"FAQ/#why-does-klipper-report-errors-i-lost-my-print","title":"Why does Klipper report errors? I lost my print!","text":"<p>Short answer: We want to know if our printers detect a problem so that the underlying issue can be fixed and we can obtain great quality prints. We definitely do not want our printers to silently produce low quality prints.</p> <p>Long answer: Klipper has been engineered to automatically workaround many transient problems. For example, it automatically detects communication errors and will retransmit; it schedules actions in advance and buffers commands at multiple layers to enable precise timing even with intermittent interference. However, should the software detect an error that it can not recover from, if it is commanded to take an invalid action, or if it detects it is hopelessly unable to perform its commanded task, then Klipper will report an error. In these situations there is a high risk of producing a low-quality print (or worse). It is hoped that alerting the user will empower them to fix the underlying issue and improve the overall quality of their prints.</p> <p>There are some related questions: Why doesn't Klipper pause the print instead? Report a warning instead? Check for errors before the print? Ignore errors in user typed commands? etc? Currently Klipper reads commands using the G-Code protocol, and unfortunately the G-Code command protocol is not flexible enough to make these alternatives practical today. There is developer interest in improving the user experience during abnormal events, but it is expected that will require notable infrastructure work (including a shift away from G-Code).</p>"},{"location":"FAQ/#how-do-i-upgrade-to-the-latest-software","title":"How do I upgrade to the latest software?","text":"<p>The first step to upgrading the software is to review the latest config changes document. On occasion, changes are made to the software that require users to update their settings as part of a software upgrade. It is a good idea to review this document prior to upgrading.</p> <p>When ready to upgrade, the general method is to ssh into the Raspberry Pi and run:</p> <pre><code>cd ~/klipper\ngit pull\n~/klipper/scripts/install-octopi.sh\n</code></pre> <p>Then one can recompile and flash the micro-controller code. For example:</p> <pre><code>make menuconfig\nmake clean\nmake\n\nsudo service klipper stop\nmake flash FLASH_DEVICE=/dev/ttyACM0\nsudo service klipper start\n</code></pre> <p>However, it's often the case that only the host software changes. In this case, one can update and restart just the host software with:</p> <pre><code>cd ~/klipper\ngit pull\nsudo service klipper restart\n</code></pre> <p>If after using this shortcut the software warns about needing to reflash the micro-controller or some other unusual error occurs, then follow the full upgrade steps outlined above.</p> <p>If any errors persist then double check the config changes document, as you may need to modify the printer configuration.</p> <p>Note that the RESTART and FIRMWARE_RESTART g-code commands do not load new software - the above \"sudo service klipper restart\" and \"make flash\" commands are needed for a software change to take effect.</p>"},{"location":"FAQ/#how-do-i-uninstall-klipper","title":"How do I uninstall Klipper?","text":"<p>On the firmware end, nothing special needs to happen. Just follow the flashing directions for the new firmware.</p> <p>On the raspberry pi end, an uninstall script is available in scripts/klipper-uninstall.sh. For example:</p> <pre><code>sudo ~/klipper/scripts/klipper-uninstall.sh\nrm -rf ~/klippy-env ~/klipper\n</code></pre>"},{"location":"Features/","title":"Features","text":"<p>Klipper has several compelling features:</p> <ul> <li> <p>High precision stepper movement. Klipper utilizes an application   processor (such as a low-cost Raspberry Pi) when calculating printer   movements. The application processor determines when to step each   stepper motor, it compresses those events, transmits them to the   micro-controller, and then the micro-controller executes each event   at the requested time. Each stepper event is scheduled with a   precision of 25 micro-seconds or better. The software does not use   kinematic estimations (such as the Bresenham algorithm) - instead it   calculates precise step times based on the physics of acceleration   and the physics of the machine kinematics. More precise stepper   movement provides quieter and more stable printer operation.</p> </li> <li> <p>Best in class performance. Klipper is able to achieve high stepping   rates on both new and old micro-controllers. Even old 8bit   micro-controllers can obtain rates over 175K steps per second. On   more recent micro-controllers, several million steps per second are   possible. Higher stepper rates enable higher print velocities. The   stepper event timing remains precise even at high speeds which   improves overall stability.</p> </li> <li> <p>Klipper supports printers with multiple micro-controllers. For   example, one micro-controller could be used to control an extruder,   while another controls the printer's heaters, while a third controls   the rest of the printer. The Klipper host software implements clock   synchronization to account for clock drift between   micro-controllers. No special code is needed to enable multiple   micro-controllers - it just requires a few extra lines in the config   file.</p> </li> <li> <p>Configuration via simple config file. There's no need to reflash the   micro-controller to change a setting. All of Klipper's configuration   is stored in a standard config file which can be easily edited. This   makes it easier to setup and maintain the hardware.</p> </li> <li> <p>Klipper supports \"Smooth Pressure Advance\" - a mechanism to account   for the effects of pressure within an extruder. This reduces   extruder \"ooze\" and improves the quality of print corners. Klipper's   implementation does not introduce instantaneous extruder speed   changes, which improves overall stability and robustness.</p> </li> <li> <p>Klipper supports \"Input Shaping\" to reduce the impact of vibrations   on print quality. This can reduce or eliminate \"ringing\" (also known   as \"ghosting\", \"echoing\", or \"rippling\") in prints. It may also   allow one to obtain faster printing speeds while still maintaining   high print quality.</p> </li> <li> <p>Klipper uses an \"iterative solver\" to calculate precise step times   from simple kinematic equations. This makes porting Klipper to new   types of robots easier and it keeps timing precise even with complex   kinematics (no \"line segmentation\" is needed).</p> </li> <li> <p>Klipper is hardware agnostic. One should get the same precise timing   independent of the low-level electronics hardware. The Klipper   micro-controller code is designed to faithfully follow the schedule   provided by the Klipper host software (or prominently alert the user   if it is unable to). This makes it easier to use available hardware,   to upgrade to new hardware, and to have confidence in the hardware.</p> </li> <li> <p>Portable code. Klipper works on ARM, AVR, and PRU based   micro-controllers. Existing \"reprap\" style printers can run Klipper   without hardware modification - just add a Raspberry Pi. Klipper's   internal code layout makes it easier to support other   micro-controller architectures as well.</p> </li> <li> <p>Simpler code. Klipper uses a very high level language (Python) for   most code. The kinematics algorithms, the G-code parsing, the   heating and thermistor algorithms, etc. are all written in Python.   This makes it easier to develop new functionality.</p> </li> <li> <p>Custom programmable macros. New G-Code commands can be defined in   the printer config file (no code changes are necessary). Those   commands are programmable - allowing them to produce different   actions depending on the state of the printer.</p> </li> <li> <p>Builtin API server. In addition to the standard G-Code interface,   Klipper supports a rich JSON based application interface. This   enables programmers to build external applications with detailed   control of the printer.</p> </li> </ul>"},{"location":"Features/#additional-features","title":"Additional features","text":"<p>Klipper supports many standard 3d printer features:</p> <ul> <li> <p>Several web interfaces available. Works with Mainsail, Fluidd,   OctoPrint and others. This allows the printer to be controlled using   a regular web-browser. The same Raspberry Pi that runs Klipper can   also run the web interface.</p> </li> <li> <p>Standard G-Code support. Common g-code commands that are produced by   typical \"slicers\" (SuperSlicer, Cura, PrusaSlicer, etc.) are   supported.</p> </li> <li> <p>Support for multiple extruders. Extruders with shared heaters and   extruders on independent carriages (IDEX) are also supported.</p> </li> <li> <p>Support for cartesian, delta, corexy, corexz, hybrid-corexy,   hybrid-corexz, deltesian, rotary delta, polar, and cable winch style   printers.</p> </li> <li> <p>Automatic bed leveling support. Klipper can be configured for basic   bed tilt detection or full mesh bed leveling. If the bed uses   multiple Z steppers then Klipper can also level by independently   manipulating the Z steppers. Most Z height probes are supported,   including BL-Touch probes and servo activated probes.</p> </li> <li> <p>Automatic delta calibration support. The calibration tool can   perform basic height calibration as well as an enhanced X and Y   dimension calibration. The calibration can be done with a Z height   probe or via manual probing.</p> </li> <li> <p>Run-time \"exclude object\" support. When configured, this module may   facilitate canceling of just one object in a multi-part print.</p> </li> <li> <p>Support for common temperature sensors (eg, common thermistors,   AD595, AD597, AD849x, PT100, PT1000, MAX6675, MAX31855, MAX31856,   MAX31865, BME280, HTU21D, DS18B20, and LM75). Custom thermistors and   custom analog temperature sensors can also be configured. One can   monitor the internal micro-controller temperature sensor and the   internal temperature sensor of a Raspberry Pi.</p> </li> <li> <p>Basic thermal heater protection enabled by default.</p> </li> <li> <p>Support for standard fans, nozzle fans, and temperature controlled   fans. No need to keep fans running when the printer is idle. Fan   speed can be monitored on fans that have a tachometer.</p> </li> <li> <p>Support for run-time configuration of TMC2130, TMC2208/TMC2224,   TMC2209, TMC2660, and TMC5160 stepper motor drivers. There is also   support for current control of traditional stepper drivers via   AD5206, DAC084S085, MCP4451, MCP4728, MCP4018, and PWM pins.</p> </li> <li> <p>Support for common LCD displays attached directly to the printer. A   default menu is also available. The contents of the display and menu   can be fully customized via the config file.</p> </li> <li> <p>Constant acceleration and \"look-ahead\" support. All printer moves   will gradually accelerate from standstill to cruising speed and then   decelerate back to a standstill. The incoming stream of G-Code   movement commands are queued and analyzed - the acceleration between   movements in a similar direction will be optimized to reduce print   stalls and improve overall print time.</p> </li> <li> <p>Klipper implements a \"stepper phase endstop\" algorithm that can   improve the accuracy of typical endstop switches. When properly   tuned it can improve a print's first layer bed adhesion.</p> </li> <li> <p>Support for filament presence sensors, filament motion sensors, and   filament width sensors.</p> </li> <li> <p>Support for measuring and recording acceleration using an adxl345,   mpu9250, and mpu6050 accelerometers.</p> </li> <li> <p>Support for limiting the top speed of short \"zigzag\" moves to reduce   printer vibration and noise. See the kinematics   document for more information.</p> </li> <li> <p>Sample configuration files are available for many common printers.   Check the config directory for a list.</p> </li> </ul> <p>To get started with Klipper, read the installation guide.</p>"},{"location":"Features/#step-benchmarks","title":"Step Benchmarks","text":"<p>Below are the results of stepper performance tests. The numbers shown represent total number of steps per second on the micro-controller.</p> Micro-controller 1 stepper active 3 steppers active 16Mhz AVR 157K 99K 20Mhz AVR 196K 123K SAMD21 686K 471K STM32F042 814K 578K Beaglebone PRU 866K 708K STM32G0B1 1103K 790K STM32F103 1180K 818K SAM3X8E 1273K 981K SAM4S8C 1690K 1385K LPC1768 1923K 1351K LPC1769 2353K 1622K RP2040 2400K 1636K SAM4E8E 2500K 1674K SAMD51 3077K 1885K STM32F407 3652K 2459K STM32F446 3913K 2634K STM32H743 9091K 6061K <p>If unsure of the micro-controller on a particular board, find the appropriate config file, and look for the micro-controller name in the comments at the top of that file.</p> <p>Further details on the benchmarks are available in the Benchmarks document.</p>"},{"location":"Overview/","title":"Overview","text":"<p>Welcome to the Klipper documentation. If new to Klipper, start with the features and installation documents.</p>"},{"location":"Overview/#overview-information","title":"Overview information","text":"<ul> <li>Features: A high-level list of features in Klipper.</li> <li>FAQ: Frequently asked questions.</li> <li>Releases: The history of Klipper releases.</li> <li>Config changes: Recent software changes that may require users to update their printer config file.</li> <li>Contact: Information on bug reporting and general communication with the Klipper developers.</li> </ul>"},{"location":"Overview/#installation-and-configuration","title":"Installation and Configuration","text":"<ul> <li>Installation: Guide to installing Klipper.</li> <li>Config Reference: Description of config   parameters.</li> <li>Rotation Distance: Calculating the     rotation_distance stepper parameter.</li> <li>Config checks: Verify basic pin settings in the   config file.</li> <li>Bed level: Information on \"bed leveling\" in Klipper.</li> <li>Delta calibrate: Calibration of delta     kinematics.</li> <li>Probe calibrate: Calibration of automatic Z     probes.</li> <li>BL-Touch: Configure a \"BL-Touch\" Z probe.</li> <li>Manual level: Calibration of Z endstops (and     similar).</li> <li>Bed Mesh: Bed height correction based on XY     locations.</li> <li>Endstop phase: Stepper assisted Z endstop     positioning.</li> <li>Resonance compensation: A tool to   reduce ringing in prints.</li> <li>Measuring resonances: Information on     using adxl345 accelerometer hardware to measure resonance.</li> <li>Pressure advance: Calibrate extruder   pressure.</li> <li>G-Codes: Information on commands supported by Klipper.</li> <li>Command Templates: G-Code macros and   conditional evaluation.</li> <li>Status Reference: Information available to     macros (and similar).</li> <li>TMC Drivers: Using Trinamic stepper motor drivers   with Klipper.</li> <li>Multi-MCU Homing: Homing and probing using multiple micro-controllers.</li> <li>Slicers: Configure \"slicer\" software for Klipper.</li> <li>Skew correction: Adjustments for axes not   perfectly square.</li> <li>PWM tools: Guide on how to use PWM controlled   tools such as lasers or spindles.</li> <li>Exclude Object: The guide to the Exclude Objecs   implementation.</li> </ul>"},{"location":"Overview/#developer-documentation","title":"Developer Documentation","text":"<ul> <li>Code overview: Developers should read this   first.</li> <li>Kinematics: Technical details on how Klipper   implements motion.</li> <li>Protocol: Information on the low-level messaging   protocol between host and micro-controller.</li> <li>API Server: Information on Klipper's command and   control API.</li> <li>MCU commands: A description of low-level commands   implemented in the micro-controller software.</li> <li>CAN bus protocol: Klipper CAN bus message   format.</li> <li>Debugging: Information on how to test and debug   Klipper.</li> <li>Benchmarks: Information on the Klipper benchmark   method.</li> <li>Contributing: Information on how to submit   improvements to Klipper.</li> <li>Packaging: Information on building OS packages.</li> </ul>"},{"location":"Overview/#device-specific-documents","title":"Device Specific Documents","text":"<ul> <li>Example configs: Information on adding an   example config file to Klipper.</li> <li>SDCard Updates: Flash a micro-controller by   copying a binary to an sdcard in the micro-controller.</li> <li>Raspberry Pi as Micro-controller: Details   for controlling devices wired to the GPIO pins of a Raspberry Pi.</li> <li>Beaglebone: Details for running Klipper on the   Beaglebone PRU.</li> <li>Bootloaders: Developer information on   micro-controller flashing.</li> <li>CAN bus: Information on using CAN bus with Klipper.</li> <li>TSL1401CL filament width sensor</li> <li>Hall filament width sensor</li> </ul>"}]}